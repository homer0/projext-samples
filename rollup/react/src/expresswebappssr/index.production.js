import fs from 'fs';
import express from 'express';
import { Logger } from 'wootils/node/logger';
import ReactDOM from 'react-dom/server';
import React from 'react';
import Main from '../webapp/components/main/main.component';

// Define the port for the express app.
const port = 2509;
// Create the instance of the app.
const app = express();
// Create a logger to show a message when the app starts.
const logger = new Logger();
/**
 * Since this file is only used on production builds, it's assumed that `webapp` is already built
 * and on the parent directory, so this method goes there looking for the HTML template in order
 * to inject the rendered version of the `Main` ocmponent.
 * @return {Promise<string,Error>} If everything goes well, it will return the HTML ready to serve.
 */
const getHTML = () => new Promise((resolve, reject) => {
  // Set the path to the HTML file.
  const htmlPath = '../webapp/index.html';
  // Read the HTML file.
  fs.readFile(htmlPath, 'utf-8', (error, data) => {
    // Reject if something went wrong.
    if (error) {
      reject(error);
    } else {
      // Render the `Main` component into a string.
      const component = ReactDOM.renderToString(<Main />);
      // Replace it, using a very awful `RegExp`, on the HTML contents.
      const html = data.replace(/(<div id="app">)(<\/div>)/i, `$1${component}$2`);
      // Resolve with the updated HTML.
      resolve(html);
    }
  });
});
/**
 * This is an express middleware that checks if the request is for the server root in order to
 * serve the pre rendered frontend. If the request is not for the server root or something went
 * wrong while rendering the frontend, it will just fallback to render the HTML when the frontend
 * gets loaded and executed on the browser (aka, it will fail silently).
 * @param {Request}  req  The express Request object.
 * @param {Response} res  The express Response object.
 * @param {Function} next The function you use to indicate that express should move to the next
 *                        middleware on the chain.
 */
const ssrMiddleware = (req, res, next) => {
  // If the request is for the server root...
  if (req.originalUrl === '/') {
    // ...then try to get the pre rendered HTML.
    getHTML()
    .then((html) => {
      // Serve the HTML.
      res.setHeader('Content-Type', 'text/html');
      res.write(html);
      res.end();
    })
    .catch((error) => {
      // If something went wrong, log it on the console, but continue as if nothing happened.
      logger.warning('Something went wrong with the SSR');
      logger.error(error);
      next();
    });
  } else {
    // ...otherwise, move to the next middleware.
    next();
  }
};

// Tell express to use the server side rendering middleware.
app.use(ssrMiddleware);
// Send all assets requests to the `webapp` folder.
app.use('/', express.static('../webapp'));
/**
 * Fallback the requests to the current directory. The reason of this is that when rendering from
 * this target, if a component uses an asset, the asset gets generated with a different hash that if
 * it were generated by the `webapp`, so even if the file is the same, the `webapp` version won't
 * have it with the same name as this one.
 */
app.use('/', express.static('./'));

// Start the app.
app.listen(port, () => {
  logger.success(`Starting on port ${port}`);
});
